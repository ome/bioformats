/*
 * #%L
 * OME-XML C++ library for working with OME-XML metadata structures.
 * %%
 * Copyright © 2006 - 2015 Open Microscopy Environment:
 *   - Massachusetts Institute of Technology
 *   - National Institutes of Health
 *   - University of Dundee
 *   - Board of Regents of the University of Wisconsin-Madison
 *   - Glencoe Software, Inc.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of any organization.
 * #L%
 */

/*─────────────────────────────────────────────────────────────────────────────
 *
 * THIS IS AUTOMATICALLY GENERATED CODE.  DO NOT MODIFY.
 *
 *─────────────────────────────────────────────────────────────────────────────
 */

{% if fu.SOURCE_TYPE == "header" %}\
#ifndef ${fu.GUARD}
#define ${fu.GUARD}

#include <algorithm>
#include <list>
#include <stdexcept>
#include <string>
#include <vector>

#include <ome/common/log.h>

#include <ome/common/xml/dom/Document.h>
#include <ome/common/xml/dom/Element.h>
#include <ome/common/xml/dom/Node.h>
#include <ome/common/xml/dom/NodeList.h>

{% for include in klass.header_dependencies %}\
#include <${include}>
{% end for%}\
{% end header%}\
{% if fu.SOURCE_TYPE == "source" %}\
#include <sstream>

#include <ome/common/xml/String.h>

#include <ome/xml/Document.h>
#include <ome/xml/model/ModelException.h>
#include <ome/xml/model/detail/Parse.h>

#include <boost/format.hpp>

{% for include in klass.source_dependencies %}\
#include <${include}>
{% end for%}\

using boost::format;
{% end source%}\

namespace ome
{
  namespace xml
  {
    namespace model
    {

{% if fu.SOURCE_TYPE == "header" %}\
{% if len(klass.forward) %}\
      // Forward declarations.
{% end if %}\
{% for f in klass.forward %}\
      class ${f};
{% end for %}\

      /**
       * ${klass.name} model object.
       */
{% if klass.parentName is not None %}\
      class ${klass.name} : public ${klass.parentName}
{% end has parentName %}\
{% if klass.parentName is None %}\
      class ${klass.name}
{% end no parentName %}\
      {
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\

      /// Private implementation details of ${klass.name} model object.
      class ${klass.name}::Impl
      {
      public:
{% if len(klass.instanceVariables) > 0 %}\
{% for prop in klass.instanceVariables %}\
{% if prop[3] is not None %}\
        /// ${prop[3]}
{% end has comment %}\
{% if prop[0] is not None %}\
        ${prop[0]} ${prop[1]};
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\

        /// Default constructor.
{% if len(klass.instanceVariables) > 0 %}\
        Impl():
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(${prop[2]})
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}()
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(${prop[2]}),
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\
{% if len(klass.instanceVariables) == 0 %}\
        Impl()
{% end no instanceVariables %}\
         {
         }

        /// Copy constructor
{% if len(klass.instanceVariables) > 0 %}\
        Impl(const Impl& copy):
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(copy.${prop[1]})
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(copy.${prop[1]})
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(copy.${prop[1]}),
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(copy.${prop[1]}),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\
{% if len(klass.instanceVariables) == 0 %}\
        Impl(const Impl& /* copy */)
{% end no instanceVariables %}\
        {
        }
      };

      // ModelObject: ${klass.name}
      // Namespace:   ${klass.namespace}
      //
      // Parent:                    ${klass.parentName}
{% if klass.modelBaseType is not None %}\
      // InstanceVariableName:      ${klass.instanceVariableName}
      // ModelBaseType:             ${klass.modelBaseType}
{% end %}\
{% if klass.langBaseType is not None %}\
      // LangBaseType:              ${klass.langBaseType}
      // LangType:                  ${klass.langType}
      // LangTypeNS:                ${klass.langTypeNS}
{% end %}\
      //
      // Abstract:                  ${klass.isAbstract}
      // AbstractProprietary:       ${klass.isAbstractProprietary}
      // ParentAbstractProprietary: ${klass.isParentAbstractProprietary}
      // Annotation:                ${klass.isAnnotation}
      // Annotated:                 ${klass.isAnnotated}
      // Described:                 ${klass.isDescribed}
      // Named:                     ${klass.isNamed}
      // Reference:                 ${klass.isReference}
      //
      // Properties:
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
      //   ${prop[1]}
      //     Instance type: ${prop[0]}
{% if prop[2] is not None %}\
      //     Default:       ${prop[2]}
{% end no default %}\
{% if prop[3] is not None %}\
      //     Comment:       ${prop[3]}
{% end no comment %}\
{% end has instance type %}\
{% end for %}\

{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
      private:
        class Impl;
        /// Private implementation details.
        ome::compat::shared_ptr<Impl> impl;

      public:
        /// Default constructor.
        ${klass.name}();

{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name}():
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
        ${klass.parentName}(),
{% end has parent %}\
        impl(ome::compat::make_shared<Impl>())
      {
#ifdef OME_HAVE_BOOST_LOG
        logger.add_attribute("ClassName", logging::attributes::constant<std::string>("${klass.name}"));
#else // ! OME_HAVE_BOOST_LOG
        logger.className("${klass.name}");
#endif // OME_HAVE_BOOST_LOG
      }

{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Copy constructor.
         *
         * @param copy the ${klass.name} to copy.
         */
        ${klass.name} (const ${klass.name}& copy);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name} (const ${klass.name}& copy):
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
        ${klass.parentName}(copy),
{% end has parent %}\
        impl(ome::compat::make_shared<Impl>(*copy.impl))
      {
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /// Destructor.
        virtual
        ~${klass.name} ();
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::~${klass.name} ()
      {
      }
{% end source %}\

{% if not klass.isAbstract and not klass.isAbstractProprietary %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Create a ${klass.name} model object from DOM element.
         *
         * @param element root of the XML DOM tree to from which to
         * construct the model object graph.
         * @param model handler for the OME model used to track
         * instances and references seen during the update.
         * @throws EnumerationException if there is an error
         * instantiating an enumeration during model object creation,
         * or ModelException if there are any consistency or validity
         * errors found during processing.
         *
         * @returns a new model object.
         */
        static ome::compat::shared_ptr< ${klass.name}>
        create(const common::xml::dom::Element& element,
               ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ome::compat::shared_ptr< ${klass.name}>
      ${klass.name}::create(const common::xml::dom::Element& element,
                              ${lang.omexml_model_package}::OMEModel& model)
      {
        ome::compat::shared_ptr< ${klass.name}> newinstance(ome::compat::make_shared< ${klass.name}>());
        newinstance->update(element, model);
        return newinstance;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        // Documented in superclass.
        const std::string&
        elementName() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::elementName() const
      {
        static const std::string type("${klass.name}");
        return type;
      }
{% end source %}\
{% end not Abstract %}\

{% if fu.SOURCE_TYPE == "header" %}\
        // Documented in superclass.
        bool
        validElementName(const std::string& name) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::validElementName(const std::string& name) const
      {
        static const std::string expectedTagName("${klass.name}");

        return expectedTagName == name || ${klass.parentName}::validElementName(name);
      }
{% end source %}\

{% if len(customContent) > 0 %}\
{% if fu.SOURCE_TYPE == "header" %}\
      private:
        /// Assignment operator (deleted).
        ${klass.name}&
        operator= (const ${klass.name}&);

      public:
{% end header %}\
        // -- Custom content from ${klass.name} specific template --

${customContent}\
{% end custom content %}\
{% if fu.SOURCE_TYPE == "header" %}\

        // -- OMEModelObject API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::update
        virtual void
        update(const common::xml::dom::Element&  element,
               ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\

      void
      ${klass.name}::update(const common::xml::dom::Element&  element,
                            ${lang.omexml_model_package}::OMEModel& model)
      {
        ${klass.parentName}::update(element, model);

{% if klass.langBaseType is not None %}\
        {
          // Element's text data
          std::string text(element.getTextContent());
{% if klass.langBaseType != 'std::string' %}\
          if (!text.empty())
            {
              set_value(text
                        *this, &${klass.name}::setValue,
                        "${klass.name}", "value");
            }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
          this->impl->value = text;
{% end %}\
        }
{% end %}\
        const std::string tagName(stripNamespacePrefix(element.getTagName()));
        if (!validElementName(tagName))
          {
            BOOST_LOG_SEV(logger, ome::logging::trivial::warning)
              << tagName << " is an invalid element name for ${klass.name}";
          }
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.name in customUpdatePropertyContent %}\
{% if debug %}\
        // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customUpdatePropertyContent[prop.name]}
{% if debug %}\
        // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end %}\
{% when prop.isReference %}\
        // Element reference ${prop.name}
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<common::xml::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            ome::compat::shared_ptr<${prop.name}> rcptr(ome::compat::make_shared< ${prop.name}>());
            rcptr->setID(elem->getAttribute("ID"));
            ome::compat::shared_ptr<Reference> rptr(ome::compat::static_pointer_cast<Reference>(rcptr));
            ome::compat::shared_ptr< ${lang.omexml_model_package}::OMEModelObject> optr(ome::compat::static_pointer_cast<${lang.omexml_model_package}::OMEModelObject>(shared_from_this()));
            model.addReference(optr, rptr);
          }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
        // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.isAttribute and prop.name == "ID" %}\
        if (!element.hasAttribute("ID") && getID().empty())
          {
            throw ModelException("${klass.name} missing required ID property");
          }
        if (element.hasAttribute("ID"))
           {
             // ID property
{% if klass.langBaseType != 'std::string' %}\
             set_value(element.getAttribute("${prop.name}"),
                       *this, &${klass.name}::set${prop.methodName},
                       "${klass.name}", "${prop.name}");
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
             set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end %}\
             // Adding this model object to the model handler
             ome::compat::shared_ptr< ${lang.omexml_model_package}::OMEModelObject> thisptr(ome::compat::dynamic_pointer_cast<  ${lang.omexml_model_package}::OMEModelObject>(shared_from_this()));
             model.addModelObject(getID(), thisptr);
           }
{% end %}\
{% when prop.isAttribute %}\
        if (element.hasAttribute("${prop.name}"))
          {
{% if prop.isEnumeration %}\
            // Attribute property which is an enumeration ${prop.name}
{% if prop.minOccurs == 0 %}\
            std::string text(element.getAttribute("${prop.name}"));
            ${prop.instanceVariableType} nattr(ome::compat::make_shared< ${prop.langTypeNS}>(text));
            set${prop.methodName}(nattr);
{% end %}\
{% if prop.minOccurs > 0 %}\
            set${prop.methodName}(${prop.langTypeNS}(element.getAttribute("${prop.name}")));
{% end %}\
{% end %}\
{% if not prop.isEnumeration %}\
            // Attribute property ${prop.name}
            {
{% if prop.instanceVariableType != 'std::string' %}\
              set_value(element.getAttribute("${prop.name}"),
                        *this, &${klass.name}::set${prop.methodName},
                        "${klass.name}", "${prop.name}");
{% end %}\
{% if prop.instanceVariableType == 'std::string' %}\
              set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end %}\
            }
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstractProprietary or not prop.isAttribute) %}\
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        if (${prop.name}_nodeList.size() > 1)
          {
            format fmt("${prop.name} node list size %1% != 1");
            fmt % ${prop.name}_nodeList.size();
            throw ModelException(fmt.str());
          }
        else if (${prop.name}_nodeList.size() != 0)
          {
{% if prop.isComplex() and not klass.isAbstractProprietary %}\
            // Element property ${prop.name} which is complex (has sub-elements)
{% if prop.minOccurs == 0 or (not lang.hasPrimitiveType(prop.langType) and not prop.isEnumeration) %}\
            common::xml::dom::Element elem(${prop.name}_nodeList.at(0));
            // While ome::compat::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
            ${prop.instanceVariableType} p(${prop.langTypeNS}::create(elem, model));
{% end %}\
{% if prop.minOccurs > 0 and (lang.hasPrimitiveType(prop.langType) or prop.isEnumeration) %} \
            ${prop.langTypeNS} p(${prop.name}_nodeList.at(0), model);
{% end %}\
            set${prop.methodName}(p);
{% end %}\
{% if not prop.isComplex() %}\
            // Element property ${prop.name} which is not complex (has no
            // sub-elements)
            std::string text(${prop.name}_nodeList.at(0).getTextContent());
{% if prop.minOccurs == 0 %}\
            ${prop.instanceVariableType} ns(ome::compat::make_shared< ${prop.langTypeNS}>(text));
            set${prop.methodName}(ns);
{% end %}\
{% if prop.minOccurs > 0 %}\
{% if prop.langTypeNS != 'std::string' %}\
             set_value(text,
                       *this, &${klass.name}::set${prop.methodName},
                       "${klass.name}", "${prop.name}");
{% end %}\
{% if prop.langTypeNS == 'std::string' %}\
            set${prop.methodName}(text);
{% end %}\
{% end %}\
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() and not klass.isAbstractProprietary %}\
{% if prop.isAbstractProprietary %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once. The element's model
        // object type is also abstract so we need to have a handler for
        // each "subclass".
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<common::xml::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
{% for inner_prop in model.getObjectByName(prop.name).properties.values() %}\
{% if not inner_prop.isAttribute and inner_prop.isComplex() and not inner_prop.isReference and inner_prop.isChoice %}\
            std::vector<common::xml::dom::Element> ${inner_prop.name}_nodeList(getChildrenByTagName(*elem, "${inner_prop.name}"));
                 for (std::vector<common::xml::dom::Element>::iterator inner_elem = ${inner_prop.name}_nodeList.begin();
                 inner_elem != ${inner_prop.name}_nodeList.end();
                 ++inner_elem)
                   {
                     // While ome::compat::make_shared<> works, here,
                     // boost::make_shared<> does not, so use new
                     // directly.
                     ome::compat::shared_ptr<${prop.methodName}> object(${inner_prop.langTypeNS}::create(*elem, model));
                     object->update(*inner_elem, model);
                     add${prop.methodName}(object);
                   }
{% end %}\
{% end %}\
          }
{% end %}\
{% if not prop.isAbstractProprietary %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<common::xml::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            // While ome::compat::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
            ome::compat::shared_ptr<${prop.methodName}> object(${prop.langTypeNS}::create(*elem, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% end %}\
{% when prop.maxOccurs > 1 %}\
        // Element property ${prop.name} which is not complex (has no
        // sub-elements) which occurs more than once
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName("${prop.name}"));
        for (std::vector<common::xml::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            std::string text(element.getTextContent());
            ome::compat::shared_ptr<${prop.methodName}> object(${prop.langTypeNS}::create(text, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% otherwise %}\
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\
      }
{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\

      public:
        // -- ${klass.name} API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::link
        bool
        link (ome::compat::shared_ptr<Reference>& reference,
              ome::compat::shared_ptr< ${lang.omexml_model_package}::OMEModelObject>& object);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link (ome::compat::shared_ptr<Reference>& reference,
                           ome::compat::shared_ptr< ${lang.omexml_model_package}::OMEModelObject>& object)
      {
        if (${klass.parentName}::link(reference, object))
          {
            return true;
          }
{% for prop in klass.properties.values() %}\
{% if prop.isReference %}\
        if (ome::compat::dynamic_pointer_cast<${prop.name}>(reference))
          {
            /// @todo This bit is silly; why do we have two dynamic_casts here.
            ome::compat::shared_ptr<${prop.langTypeNS}> o_casted = ome::compat::dynamic_pointer_cast<${prop.langTypeNS}>(object);
            if (o_casted)
              {
{% if not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.type}(ome::compat::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.name}${prop.methodName}(ome::compat::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
{% end %}\
{% end %}\
{% if prop.maxOccurs > 1 %}\
{% if not prop.isReference and not prop.isBackReference %}\
                if (contains(this->impl->${prop.instanceVariableName}, o_casted))
                  {
                    this->impl->${prop.instanceVariableName}.push_back(o_casted);
                  }
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
                typedef OMEModelObject::indexed_container<${prop.langTypeNS}, ome::compat::weak_ptr>::type::nth_index<1>::type container_set_type;
                container_set_type::iterator it(this->impl->${prop.instanceVariableName}.get<1>().find(o_casted));
                if (it != this->impl->${prop.instanceVariableName}.get<1>().end())
                  {
                    this->impl->${prop.instanceVariableName}.push_back(o_casted);
                  }
{% end %}\
{% end %}\
{% if prop.maxOccurs == 1 %}\
                this->impl->${prop.instanceVariableName} = o_casted;
{% end %}\
                return true;
              }
          }
{% end %}\
{% end %}\
        BOOST_LOG_SEV(logger, ome::logging::trivial::warning)
          << "Unable to handle reference of type: "
          << typeid(reference).name();
        return false;
      }
{% end source %}\
{% if klass.langBaseType is not None %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get element value.
         *
         * @returns the ${klass.langBaseType} value.
         */
        const ${klass.langBaseType}&
        getValue () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ${klass.langBaseType}&
      ${klass.name}::getValue () const
      {
        return this->impl->value;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set element value.
         *
         * @param value the ${klass.langBaseType} value.
         */
        void
        setValue (const ${klass.langBaseType}& value);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::setValue (const ${klass.langBaseType}& value)
      {
        this->impl->value = value;
      }
{% end source %}\
{% end not object %}\
\
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when (prop.isReference or prop.isBackReference) and prop.maxOccurs > 1 %}
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOfLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOfLinked${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName}.size();
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the linked ${prop.methodName} list.
         *
         * @returns a reference to the list.
         */
        ${prop.instanceVariableType}
        getLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.instanceVariableType}
      ${klass.name}::getLinked${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const ome::compat::weak_ptr<${prop.langTypeNS}>&
        getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ome::compat::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const
      {
        return this->impl->${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set linked ${prop.methodName}.
         *
         * @note The index must be valid.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const ome::compat::weak_ptr<${prop.langTypeNS}>&
        setLinked${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                     const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ome::compat::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::setLinked${prop.methodName}(${prop.instanceVariableType}::size_type index,
                                                 const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isReference and not prop.isBackReference %}\
        return this->impl->${prop.instanceVariableName}.at(index) = ${prop.argumentName};
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        ${prop.instanceVariableType}::iterator it(this->impl->${prop.instanceVariableName}.iterator_to(this->impl->${prop.instanceVariableName}.at(index)));
        const ome::compat::weak_ptr<${prop.langTypeNS}> wp(${prop.argumentName});
        this->impl->${prop.instanceVariableName}.replace(it, wp);
        return *it;
{% end %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         * @returns @c true if the object was added to the internal
         * ${prop.instanceVariableName} list, otherwise @c false.
         *
         * @todo Why have a return value here; what is it used for?
         * Is this an artifact of the Java API?
         */
        bool
        link${prop.methodName} (const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link${prop.methodName} (const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.type}(ome::compat::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.name}${prop.methodName}(ome::compat::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% end %}\
{% if not prop.isReference and not prop.isBackReference %}\
        if (!contains(this->impl->${prop.instanceVariableName}, ${prop.argumentName}))
          {
            this->impl->${prop.instanceVariableName}.push_back(${prop.argumentName});
            return true;
          }
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        typedef OMEModelObject::indexed_container<${prop.langTypeNS}, ome::compat::weak_ptr>::type::nth_index<1>::type container_set_type;
        container_set_type::iterator it(this->impl->${prop.instanceVariableName}.get<1>().find(${prop.argumentName}));
        if (it == this->impl->${prop.instanceVariableName}.get<1>().end())
          {
            std::pair<OMEModelObject::indexed_container<${prop.langTypeNS}, ome::compat::weak_ptr>::type::iterator, bool> res(this->impl->${prop.instanceVariableName}.push_back(ome::compat::weak_ptr<${prop.langTypeNS}>(${prop.argumentName})));
            return res.second;
          }
{% end %}\
        return false;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @returns @c true if the ${prop.methodName} was unlinked, otherwise
         * @c false if the ${prop.methodName} was not linked and could hence not be
         * unlinked.
         *
         * @todo Does the return value serve any useful purpose?  Is
         * this also inherited Java API?
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        bool
        unlink${prop.methodName} (const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::unlink${prop.methodName} (const ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.type}(ome::compat::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.name}${prop.methodName}(ome::compat::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% end %}\
        bool found = false;
        ${prop.instanceVariableType}::iterator i =
          std::find_if(this->impl->${prop.instanceVariableName}.begin(),
                       this->impl->${prop.instanceVariableName}.end(),
                       compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != this->impl->${prop.instanceVariableName}.end())
          {
            found = true;
            this->impl->${prop.instanceVariableName}.erase(i);
          }
        return found;
      }
{% end source %}\
{% end %}\
{% when prop.isReference %}
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @returns the linked ${prop.methodName}.  The pointer may be
         * null.
         */
        ${prop.retType[qualifier]}
        getLinked${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference
      ${prop.retType[qualifier]}
      ${klass.name}::getLinked${prop.methodName} ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         */
        void
        link${prop.methodName} (ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::link${prop.methodName} (ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        this->impl->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @todo This method is fairly pointless since it's equivalent
         * to linking a null pointer.  It could call @c link(0)
         * internally.
         */
        void
        unlink${prop.methodName} (ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::unlink${prop.methodName} (ome::compat::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        if (ome::compat::shared_ptr<${prop.langTypeNS}>(this->impl->${prop.instanceVariableName}) == ${prop.argumentName})
          {
            this->impl->${prop.instanceVariableName} = ome::compat::shared_ptr<${prop.langTypeNS}>();
          }
      }
{% end source %}\
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstractProprietary or prop.isAttribute or not prop.isComplex() or not prop.isChoice) %}
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} property.
         *
         * @returns the ${prop.methodName} property.
         */
        ${prop.retType[qualifier]}
        get${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      ${prop.retType[qualifier]}
      ${klass.name}::get${prop.methodName} ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set the ${prop.methodName} property.
         *
         * @param ${prop.argumentName} the value to set.
         */
        void
        set${prop.methodName} (${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      void
      ${klass.name}::set${prop.methodName} (${prop.argType} ${prop.argumentName})
      {
        this->impl->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\
{% end %}\
{% when prop.maxOccurs > 1 and not klass.isAbstractProprietary %}
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOf${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOf${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName}.size();
      }
{% end source %}\

{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} list.
         *
         * @returns a reference to the list.
         *
         */
        ${prop.retType[qualifier]}&
        get${prop.methodName}List ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.retType[qualifier]}&
      ${klass.name}::get${prop.methodName}List ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        ${prop.elementRetType[qualifier]}
        get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.elementRetType[qualifier]}
      ${klass.name}::get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier}
      {
        return this->impl->${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @throws std::out_of_range if the index is invalid.
         */
        void
        set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                               ${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                            ${prop.elementArgType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        ome::compat::weak_ptr<${klass.type}> self(ome::compat::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
{% if not prop.isReference and not prop.isBackReference %}\
        this->impl->${prop.instanceVariableName}.at(index) = ${prop.argumentName};
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        ${prop.instanceVariableType}::iterator it(this->impl->${prop.instanceVariableName}.iterator_to(this->impl->${prop.instanceVariableName}.at(index)));
        this->impl->${prop.instanceVariableName}.replace(it, ${prop.argumentName});
{% end %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Add ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to add.
         *
         * @todo Return list position?
         * @todo Detect and handle duplicates?
         */
        void
        add${prop.methodName} (${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::add${prop.methodName} (${prop.elementArgType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        ome::compat::weak_ptr<${klass.type}> self(ome::compat::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
        this->impl->${prop.instanceVariableName}.push_back(${prop.argumentName});
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Remove ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to remove.
         *
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        void
        remove${prop.methodName} (${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::remove${prop.methodName} (${prop.elementArgType} ${prop.argumentName})
      {
        ${prop.instanceVariableType}::iterator i = std::find_if(this->impl->${prop.instanceVariableName}.begin(),
                                                                this->impl->${prop.instanceVariableName}.end(),
                                                                compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != this->impl->${prop.instanceVariableName}.end())
          this->impl->${prop.instanceVariableName}.erase(i);
      }
{% end source %}\
{% end %}\
{% otherwise %}
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\

{% if klass.name == "LightSource" %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the LightSource type.
         *
         * @returns the concrete type of the LightSource.
         */
        virtual const std::string&
        getLightSourceType() const = 0;
{% end header %}\
{% end light source%}\
{% if klass.name != "AnnotationRef" and klass.parents is not None and "LightSource" in klass.parents.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        const std::string&
        getLightSourceType() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getLightSourceType() const
      {
	static const std::string type("${klass.name}");
	return type;
      }
{% end source %}\
{% end has parent light source %}\
{% if klass.name == "Shape" %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the Shape type.
         *
         * @returns the concrete type of the Shape.
         */
        virtual const std::string&
        getShapeType() const = 0;
{% end header %}\
{% end shape%}\
{% if klass.name != "AnnotationRef" and klass.parents is not None and "Shape" in klass.parents.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        const std::string&
        getShapeType() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getShapeType() const
      {
	static const std::string type("${klass.name}");
	return type;
      }
{% end source %}\
{% end has parent shape %}\

{% if not klass.isAbstractProprietary %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::asXMLElement
        virtual common::xml::dom::Element
        asXMLElement (common::xml::dom::Document& document) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      common::xml::dom::Element
      ${klass.name}::asXMLElement (common::xml::dom::Document& document) const
      {
{% if klass.name != "OME" %}\
        common::xml::dom::Element element(document.createElementNS(getXMLNamespace(), "${klass.name}"));
{% end if %}\
{% if klass.name == "OME" %}\
        common::xml::dom::Element element(document.getDocumentElement());
{% end if %}\
        return asXMLElementInternal(document, element);
      }
{% end source %}\

{% end %}\
{% if fu.SOURCE_TYPE == "header" %}\

      protected:
        // Documented in base class.
        virtual common::xml::dom::Element
        asXMLElementInternal (common::xml::dom::Document& document,
                              common::xml::dom::Element&  element) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      common::xml::dom::Element
      ${klass.name}::asXMLElementInternal (common::xml::dom::Document& document,
                                           common::xml::dom::Element&  element) const
      {
        // Create XML block for ${klass.name}

{% if klass.name == "OME" %}\
        static const std::string XSI_NAMESPACE("http://www.w3.org/2001/XMLSchema-instance");
        element.setAttribute("xmlns:xsi", XSI_NAMESPACE);
        element.setAttribute("xsi:schemaLocation", getXMLNamespace() + " " + getXMLNamespace() + "/ome.xsd");
{% end %}\
{% if klass.isAbstractProprietary %}\
        // Class is abstract so we may need to create its "container" element
        if (std::string(element.getTagName()) != "${klass.name}")
          {
            common::xml::dom::Element abstractElement =
              document.createElementNS(getXMLNamespace(), "${klass.name}");
            abstractElement.appendChild(element);
            element = abstractElement;
          }
{% end %}\
        if (!element)
          {
            common::xml::dom::Element newElement = document.createElementNS(getXMLNamespace(), "${klass.name}");
            element = newElement;
          }

{% if klass.langBaseType is not None %}\
        // Element's text data
//            if (!this->impl->value.empty()) {
{% if klass.langBaseType != 'std::string' %}\
        {
          std::ostringstream os;
          os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
          os << this->impl->value;
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
          os << std::boolalpha << this->impl->value;
{% end %}\
          element.setTextContent(os.str());
        }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
        element.setTextContent(this->impl->value);
{% end %}\
{% end %}\
{% if klass.isAnnotation %}\
        // Ensure any base annotations add their Elements first
        element = ${klass.parentName}::asXMLElementInternal(document, element);
{% end if isAnnotation %}\
{% for prop in klass.properties.values() %}\
{% if not klass.isAbstractProprietary or prop.isAttribute or not prop.isComplex() or (prop.name in fu.ANNOTATION_OVERRIDE) %}\
        {
{% choose %}\
{% when prop.name in customAsXMLElementPropertyContent %}\
{% if debug %}\
          // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customAsXMLElementPropertyContent[prop.name]}
{% if debug %}\
          // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end %}\
{% when prop.isReference and prop.maxOccurs > 1 %}\
          {
            // Reference property ${prop.name} which occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = this->impl->${prop.instanceVariableName}.begin();
                 i != this->impl->${prop.instanceVariableName}.end();
                 ++i)
              {
                // Note that this doesn't strictly need to be a
                // shared_ptr, but keep compatible with the rest of
                // the API to allow consistency for future
                // refactoring.
                ome::compat::shared_ptr<${prop.name}> o(ome::compat::make_shared< ${prop.name}>());
                ome::compat::shared_ptr<${prop.langTypeNS}> is(i->lock());
                if (is)
                  {
                    o->setID(is->getID());
                    common::xml::dom::Element child(o->asXMLElement(document));
                    element.appendChild(child);
                  }
              }
          }
{% end %}\
{% when prop.isReference %}\
          {
            // Reference property ${prop.name}
            // Note that this doesn't strictly need to be a
            // shared_ptr, but keep compatible with the rest of the
            // API to allow consistency for future refactoring.
            ome::compat::shared_ptr<${prop.name}> o(ome::compat::make_shared< ${prop.name}>());
            ome::compat::shared_ptr<${prop.langTypeNS}> sv(this->impl->${prop.instanceVariableName}.lock());
            if (sv)
              {
                o->setID(sv->getID());
                common::xml::dom::Element child(o->asXMLElement(document));
                element.appendChild(child);
              }
          }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
          // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.maxOccurs == 1 and prop.isAttribute %}\
          // Attribute property ${prop.name}
          {
            std::ostringstream os;
            os.imbue(std::locale::classic());
{% if prop.minOccurs == 1 %}\
{% if prop.langTypeNS != 'bool' %}\
          os << this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
          os << std::boolalpha << this->impl->${prop.instanceVariableName};
{% end %}\
            element.setAttribute("${prop.name}", os.str());
{% end %}\
{% if prop.minOccurs == 0 %}\
            if (this->impl->${prop.instanceVariableName})
              {
{% if prop.langTypeNS != 'bool' %}\
                os << *this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
                os << std::boolalpha << *this->impl->${prop.instanceVariableName};
{% end %}\
                element.setAttribute("${prop.name}", os.str());
              }
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs == 1 and prop.isComplex() %}\
          // Element property ${prop.name} which is complex (has
          // sub-elements)
          if (this->impl->${prop.instanceVariableName})
            {
              common::xml::dom::Element child(this->impl->${prop.instanceVariableName}->asXMLElement(document));
              element.appendChild(child);
            }
{% end %}\
{% when prop.maxOccurs == 1 %}\
          // Element property ${prop.name} which is not complex (has no
          // sub-elements)
          {
{% if prop.minOccurs == 1 %}\
            common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
            std::ostringstream os;
            os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
            os << this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
            os << std::boolalpha << this->impl->${prop.instanceVariableName};
{% end %}\
            child.setTextContent(os.str());
            element.appendChild(child);
{% end %}\
{% if prop.minOccurs == 0 %}\
            if (this->impl->${prop.instanceVariableName})
              {
                common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
                std::ostringstream os;
                os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
                os << *this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
                os << std::boolalpha << *this->impl->${prop.instanceVariableName};
{% end %}\
                child.setTextContent(os.str());
                element.appendChild(child);
              }
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() %}\
          {
            // Element property ${prop.name} which is complex (has
            // sub-elements) and occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = this->impl->${prop.instanceVariableName}.begin();
                 i != this->impl->${prop.instanceVariableName}.end();
                 ++i)
              {
                if (*i)
                  {
                    common::xml::dom::Element child((*i)->asXMLElement(document));
                    element.appendChild(child);
                  }
              }
          }
{% end %}\
{% when prop.maxOccurs > 1 %}\
          {
            // Element property ${prop.name} which is not complex (has no
            // sub-elements) which occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = this->impl->${prop.instanceVariableName}.begin();
                 i != this->impl->${prop.instanceVariableName}.end();
                 ++i)
              {
                common::xml::dom::Element this->impl->${prop.instanceVariableName}_element =
                                                                   document.createElementNS(getXMLNamespace(), "${prop.name}");
                std::ostringstream os;
                os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
                os << *i;
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
                os << std::boolalpha << *i;
{% end %}\
                this->impl->${prop.instanceVariableName}_element.setTextContent(os.str());
                common::xml::dom::Element child(this->impl->${prop.instanceVariableName}_element);
                element.appendChild(child);
              }
          }
{% end %}\
{% otherwise %}\
{% if debug %}\
          // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
        }
{% end %}\
{% end %}\
{% choose %}\
{% when klass.isAnnotation %}\
        return element;
{% end when isAnnotation %}\
{% otherwise %}\
        return ${klass.parentName}::asXMLElementInternal(document, element);
{% end otherwise %}\
{% end choose %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
      public:
       // Documented in superclass.
       const std::string&
       getXMLNamespace() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getXMLNamespace() const
      {
        static const std::string ns("${klass.namespace}");
        return ns;
      }
{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
      };
{% end header %}\

    }
  }
}

{% if fu.SOURCE_TYPE == "header" %}\
#endif // ${fu.GUARD}

/*
 * Local Variables:
 * mode:C++
 * End:
 */
{% end header %}\

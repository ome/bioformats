/*
 * #%L
 * OME-XML C++ library for working with OME-XML metadata structures.
 * %%
 * Copyright © 2006 - 2014 Open Microscopy Environment:
 *   - Massachusetts Institute of Technology
 *   - National Institutes of Health
 *   - University of Dundee
 *   - Board of Regents of the University of Wisconsin-Madison
 *   - Glencoe Software, Inc.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of any organization.
 * #L%
 */

/*─────────────────────────────────────────────────────────────────────────────
 *
 * THIS IS AUTOMATICALLY GENERATED CODE.  DO NOT MODIFY.
 *
 *─────────────────────────────────────────────────────────────────────────────
 */

{% if fu.SOURCE_TYPE == "header" %}\
#ifndef ${fu.GUARD}
#define ${fu.GUARD}

#include <algorithm>
#include <iostream>
#include <list>
#include <stdexcept>
#include <string>
#include <vector>

#include <ome/xerces/dom/Document.h>
#include <ome/xerces/dom/Element.h>
#include <ome/xerces/dom/Node.h>
#include <ome/xerces/dom/NodeList.h>

{% for include in klass.header_dependencies %}\
#include <${include}>
{% end for%}\
{% end header%}\
{% if fu.SOURCE_TYPE == "source" %}\
#include <sstream>

#include <ome/xerces/String.h>

#include <ome/xml/model/ModelException.h>

#include <boost/format.hpp>

{% for include in klass.source_dependencies %}\
#include <${include}>
{% end for%}\

using boost::format;
{% end source%}\

namespace ome
{
  namespace xml
  {
    namespace model
    {

{% if fu.SOURCE_TYPE == "header" %}\
{% if len(klass.forward) %}\
      // Forward declarations.
{% end if %}\
{% for f in klass.forward %}\
      class ${f};
{% end for %}\

{% end header %}\
{% if fu.SOURCE_TYPE == "header" %}\
      /**
       * ${klass.name} model object.
       */
{% if klass.parentName is not None %}\
      class ${klass.name} : public ${klass.parentName}
{% end has parentName %}\
{% if klass.parentName is None %}\
      class ${klass.name}
{% end no parentName %}\
      {
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      namespace
      {
        const std::string NAMESPACE("${klass.namespace}");
      }

{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
{% if len(klass.instanceVariables) > 0 %}\
      private:
{% for prop in klass.instanceVariables %}\
{% if prop[3] is not None %}\
        /// ${prop[3]}
{% end has comment %}\
{% if prop[0] is not None %}\
        ${prop[0]} ${prop[1]};
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\

{% end header %}\
{% if fu.SOURCE_TYPE == "header" %}\
      public:
{% end header %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /// Default constructor.
        ${klass.name} ();
{% end header%}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name} ():
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
{% if len(klass.instanceVariables) == 0 %}\
        ${klass.parentName}()
{% end has no instance variables %}\
{% if len(klass.instanceVariables) > 0 %}\
        ${klass.parentName}(),
{% end has instance variables %}\
{% end has parent %}\
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(${prop[2]})
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}()
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(${prop[2]}),
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}(),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
      {
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Copy constructor.
         *
         * @param copy the ${klass.name} to copy.
         */
        ${klass.name} (const ${klass.name}& copy);
{% end header%}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name} (const ${klass.name}& copy):
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
{% if len(klass.instanceVariables) == 0 %}\
        ${klass.parentName}(copy)
{% end has no instance variables %}\
{% if len(klass.instanceVariables) > 0 %}\
        ${klass.parentName}(copy),
{% end has instance variables %}\
{% end has parent %}\
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(copy.${prop[1]})
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}(copy.${prop[1]})
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(copy.${prop[1]}),
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}(copy.${prop[1]}),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
      {
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Construct a ${klass.name} recursively from an XML DOM tree.
         *
         * @param element root of the XML DOM tree to from which to
         * construct the model object graph.
         * @param model handler for the OME model used to track
         * instances and references seen during the update.
         * @throws EnumerationException if there is an error
         * instantiating an enumeration during model object creation.
         */
        ${klass.name} (xerces::dom::Element& element, ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name} (xerces::dom::Element& element, ${lang.omexml_model_package}::OMEModel& model):
{% if klass.parentName is not None %}\
{% if len(klass.instanceVariables) == 0 %}\
        ${klass.parentName}()
{% end has no instance variables %}\
{% if len(klass.instanceVariables) > 0 %}\
        ${klass.parentName}(),
{% end has instance variables %}\
{% end has parent %}\
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(${prop[2]})
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}()
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
        ${prop[1]}(${prop[2]}),
{% end has default %}\
{% if prop[2] is None %}\
        ${prop[1]}(),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
      {
        update(element, model);
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /// Destructor.
        virtual
        ~${klass.name} ();

{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::~${klass.name} ()
      {
      }
{% end source %}\
{% if len(customContent) > 0 %}\

{% if fu.SOURCE_TYPE == "header" %}\
      private:
        /// Assignment operator (deleted).
        ${klass.name}&
        operator= (const ${klass.name}&);

      public:
{% end header %}\
        // -- Custom content from ${klass.name} specific template --

${customContent}\
{% end custom content %}\
{% if fu.SOURCE_TYPE == "header" %}\

        // -- OMEModelObject API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::update
        virtual void
        update(const xerces::dom::Element&  element,
               ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\

      void
      ${klass.name}::update(const xerces::dom::Element&  element,
                            ${lang.omexml_model_package}::OMEModel& model)
      {
        ${klass.parentName}::update(element, model);
{% if klass.langBaseType is not None %}\

        {
          // Element's text data
          std::string text(element.getTextContent());
{% if klass.langBaseType != 'std::string' %}\
          if (!text.empty())
            {
              std::istringstream is(text);
              if (!(is >> this->value))
                {
                  format fmt("Failed to parse ${klass.name} value ‘%1%’");
                  fmt % text;
                  throw ModelException(fmt.str());
                }
            }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
          this->value = text;
{% end %}\
        }
{% end %}\
{% if not klass.isAbstractProprietary %}\
        std::string tagName(element.getTagName());
        if (tagName != "${klass.name}")
          {
            std::clog << "Expecting node name of ${klass.name} got " << tagName << std::endl;
          }
{% end %}\
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.name in customUpdatePropertyContent %}\
{% if debug %}\
        // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customUpdatePropertyContent[prop.name]}
{% if debug %}\
        // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end %}\
{% when prop.isReference %}\
        // Element reference ${prop.name}
        std::vector<xerces::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<xerces::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            std::shared_ptr<${prop.name}> rcptr(std::make_shared< ${prop.name}>());
            rcptr->setID(elem->getAttribute("ID"));
            std::shared_ptr<Reference> rptr(std::static_pointer_cast<Reference>(rcptr));
            std::shared_ptr< ${lang.omexml_model_package}::OMEModelObject> optr(this);
            model.addReference(optr, rptr);
          }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
        // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.isAttribute and prop.name == "ID" %}\
        if (!element.hasAttribute("ID") && getID().empty())
          {
            throw ModelException("${klass.name} missing required ID property");
          }
        if (element.hasAttribute("ID"))
           {
             // ID property
{% if klass.langBaseType != 'std::string' %}\
             ${prop.langTypeNS} id;
             std::istringstream is(element.getAttribute("${prop.name}"));
             is >> id;
             if (!is)
                {
                  format fmt("Failed to parse ${klass.name} value ‘%1%’");
                  fmt % is.str();
                  throw ModelException(fmt.str());
                }
             set${prop.methodName}(id);
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
             set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end %}\
             // Adding this model object to the model handler
             std::shared_ptr< ${lang.omexml_model_package}::OMEModelObject> thisptr(shared_from_this());
             model.addModelObject(getID(), thisptr);
           }
{% end %}\
{% when prop.isAttribute %}\
        if (element.hasAttribute("${prop.name}"))
          {
{% if prop.isEnumeration %}\
            // Attribute property which is an enumeration ${prop.name}
{% if prop.minOccurs == 0 %}\
            std::string text(element.getAttribute("${prop.name}"));
            ${prop.instanceVariableType} nattr(std::make_shared< ${prop.langTypeNS}>(text));
            set${prop.methodName}(nattr);
{% end %}\
{% if prop.minOccurs > 0 %}\
            set${prop.methodName}(${prop.langTypeNS}(element.getAttribute("${prop.name}")));
{% end %}\
{% end %}\
{% if not prop.isEnumeration %}\
            // Attribute property ${prop.name}
            {
{% if prop.instanceVariableType != 'std::string' %}\
              std::istringstream is(element.getAttribute("${prop.name}"));
{% if prop.minOccurs == 0 %}\
              ${prop.instanceVariableType} attr(std::make_shared< ${prop.langTypeNS}>());
              is >> *attr;
{% end %}\
{% if prop.minOccurs > 0 %}\
              ${prop.langTypeNS} attr;
              is >> attr;
{% end %}\
              if (!is)
                {
                  format fmt("Failed to parse ${klass.name} value ‘%1%’");
                  fmt % is.str();
                  throw ModelException(fmt.str());
                }

              set${prop.methodName}(attr);
{% end %}\
{% if prop.instanceVariableType == 'std::string' %}\
              set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end %}\
            }
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstractProprietary or not prop.isAttribute) %}\
        std::vector<xerces::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        if (${prop.name}_nodeList.size() > 1)
          {
            format fmt("${prop.name} node list size %1% != 1");
            fmt % ${prop.name}_nodeList.size();
            throw ModelException(fmt.str());
          }
        else if (${prop.name}_nodeList.size() != 0)
          {
{% if prop.isComplex() and not klass.isAbstractProprietary %}\
            // Element property ${prop.name} which is complex (has sub-elements)
{% if prop.minOccurs == 0 or (not lang.hasPrimitiveType(prop.langType) and not prop.isEnumeration) %}\
            xerces::dom::Element elem(${prop.name}_nodeList.at(0));
            // While std::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
            ${prop.instanceVariableType} p(new ${prop.langTypeNS}(elem, model));
{% end %}\
{% if prop.minOccurs > 0 and (lang.hasPrimitiveType(prop.langType) or prop.isEnumeration) %} \
            ${prop.langTypeNS} p(${prop.name}_nodeList.at(0), model);
{% end %}\
            set${prop.methodName}(p);
{% end %}\
{% if not prop.isComplex() %}\
            // Element property ${prop.name} which is not complex (has no
            // sub-elements)
            std::string text(${prop.name}_nodeList.at(0).getTextContent());
{% if prop.minOccurs == 0 %}\
            ${prop.instanceVariableType} ns(std::make_shared< ${prop.langTypeNS}>(text));
            set${prop.methodName}(ns);
{% end %}\
{% if prop.minOccurs > 0 %}\
{% if prop.langTypeNS != 'std::string' %}\
            ${prop.langTypeNS} attr;

            std::istringstream is(text);
            if (is >> attr)
              set${prop.methodName}(attr);
            else
              {
                format fmt("Failed to parse ${klass.name} ${prop.name} property value ‘%1%’");
                fmt % is.str();
                throw ModelException(fmt.str());
              }
{% end %}\
{% if prop.langTypeNS == 'std::string' %}\
            set${prop.methodName}(text);
{% end %}\
{% end %}\
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() and not klass.isAbstractProprietary %}\
{% if prop.isAbstractProprietary %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once. The element's model
        // object type is also abstract so we need to have a handler for
        // each "subclass".
        std::vector<xerces::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<xerces::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
{% for inner_prop in model.getObjectByName(prop.name).properties.values() %}\
{% if not inner_prop.isAttribute and inner_prop.isComplex() and not inner_prop.isReference and inner_prop.isChoice %}\
            std::vector<xerces::dom::Element> ${inner_prop.name}_nodeList(getChildrenByTagName(*elem, "${inner_prop.name}"));
                 for (std::vector<xerces::dom::Element>::iterator inner_elem = ${inner_prop.name}_nodeList.begin();
                 inner_elem != ${inner_prop.name}_nodeList.end();
                 ++inner_elem)
                   {
                     // While std::make_shared<> works, here,
                     // boost::make_shared<> does not, so use new
                     // directly.
                     std::shared_ptr<${prop.methodName}> object(new ${inner_prop.langTypeNS}(*elem, model));
                     object->update(*inner_elem, model);
                     add${prop.methodName}(object);
                   }
{% end %}\
{% end %}\
          }
{% end %}\
{% if not prop.isAbstractProprietary %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once
        std::vector<xerces::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (std::vector<xerces::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            // While std::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
            std::shared_ptr<${prop.methodName}> object(new ${prop.langTypeNS}(*elem, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% end %}\
{% when prop.maxOccurs > 1 %}\
        // Element property ${prop.name} which is not complex (has no
        // sub-elements) which occurs more than once
        std::vector<xerces::dom::Element> ${prop.name}_nodeList(getChildrenByTagName("${prop.name}"));
        for (std::vector<xerces::dom::Element>::iterator elem = ${prop.name}_nodeList.begin();
             elem != ${prop.name}_nodeList.end();
             ++elem)
          {
            std::string text(element.getTextContent());
            std::shared_ptr<${prop.methodName}> object(std::make_shared< ${prop.langTypeNS}>(text, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% otherwise %}\
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\
      }
{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\

      public:
        // -- ${klass.name} API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::link
        bool
        link (std::shared_ptr<Reference>& reference,
              std::shared_ptr< ${lang.omexml_model_package}::OMEModelObject>& object);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link (std::shared_ptr<Reference>& reference,
                           std::shared_ptr< ${lang.omexml_model_package}::OMEModelObject>& object)
      {
        if (${klass.parentName}::link(reference, object))
          {
            return true;
          }
{% for prop in klass.properties.values() %}\
{% if prop.isReference %}\
        if (std::dynamic_pointer_cast<${prop.name}>(reference))
          {
            /// @todo This bit is silly; why do we have two dynamic_casts here.
            std::shared_ptr<${prop.langTypeNS}> o_casted = std::dynamic_pointer_cast<${prop.langTypeNS}>(object);
            if (o_casted)
              {
{% if not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.type}(std::shared_ptr<${klass.type}>(this));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.name}${prop.methodName}(std::shared_ptr<${klass.type}>(this));
{% end %}\
{% end %}\
{% if prop.maxOccurs > 1 %}\
                if (contains(${prop.instanceVariableName}, o_casted))
                  {
                    ${prop.instanceVariableName}.push_back(o_casted);
                  }
{% end %}\
{% if prop.maxOccurs == 1 %}\
                ${prop.instanceVariableName} = o_casted;
{% end %}\
                return true;
              }
          }
{% end %}\
{% end %}\
        std::clog << "Unable to handle reference of type: " << typeid(reference).name() << std::endl;
        return false;
      }
{% end source %}\
{% if klass.langBaseType is not None %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get element value.
         *
         * @returns the ${klass.langBaseType} value.
         */
        const ${klass.langBaseType}&
        getValue () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ${klass.langBaseType}&
      ${klass.name}::getValue () const
      {
        return this->value;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set element value.
         *
         * @param value the ${klass.langBaseType} value.
         */
        void
        setValue (const ${klass.langBaseType}& value);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::setValue (const ${klass.langBaseType}& value)
      {
        this->value = value;
      }
{% end source %}\
{% end not object %}\
\
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when (prop.isReference or prop.isBackReference) and prop.maxOccurs > 1 %}
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOfLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOfLinked${prop.methodName}List () const
      {
        return ${prop.instanceVariableName}.size();
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the linked ${prop.methodName} list.
         *
         * @returns a reference to the list.
         */
        ${prop.instanceVariableType}
        getLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.instanceVariableType}
      ${klass.name}::getLinked${prop.methodName}List () const
      {
        return ${prop.instanceVariableName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const std::weak_ptr<${prop.langTypeNS}>&
        getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const
      {
        return ${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set linked ${prop.methodName}.
         *
         * @note The index must be valid.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const std::weak_ptr<${prop.langTypeNS}>&
        setLinked${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                     const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::setLinked${prop.methodName}(${prop.instanceVariableType}::size_type index,
                                                 const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        return this->${prop.instanceVariableName}.at(index) = ${prop.argumentName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         * @returns @c true if the object was added to the internal
         * ${prop.instanceVariableName} list, otherwise @c false.
         *
         * @todo Why have a return value here; what is it used for?
         * Is this an artifact of the Java API?
         */
        bool
        link${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.type}(std::shared_ptr<${klass.name}>(this));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.name}${prop.methodName}(std::shared_ptr<${klass.name}>(this));
{% end %}\
{% end %}\
        if (!contains(this->${prop.instanceVariableName}, ${prop.argumentName}))
          {
            this->${prop.instanceVariableName}.push_back(${prop.argumentName});
            return true;
          }
        return false;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @returns @c true if the ${prop.methodName} was unlinked, otherwise
         * @c false if the ${prop.methodName} was not linked and could hence not be
         * unlinked.
         *
         * @todo Does the return value serve any useful purpose?  Is
         * this also inherited Java API?
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        bool
        unlink${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::unlink${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.type}(std::shared_ptr<${klass.name}>(this));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.name}${prop.methodName}(std::shared_ptr<${klass.name}>(this));
{% end %}\
{% end %}\
        bool found = false;
        ${prop.instanceVariableType}::iterator i =
          std::find_if(this->${prop.instanceVariableName}.begin(),
                       this->${prop.instanceVariableName}.end(),
                       compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != this->${prop.instanceVariableName}.end())
          {
            found = true;
            this->${prop.instanceVariableName}.erase(i);
          }
        return found;
      }
{% end source %}\
{% end %}\
{% when prop.isReference %}
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @returns the linked ${prop.methodName}.  The pointer may be
         * null.
         */
        ${prop.retType[qualifier]}
        getLinked${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference
      ${prop.retType[qualifier]}
      ${klass.name}::getLinked${prop.methodName} ()${qualifier}
      {
        return ${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         */
        void
        link${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::link${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        this->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @todo This method is fairly pointless since it's equivalent
         * to linking a null pointer.  It could call @c link(0)
         * internally.
         */
        void
        unlink${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::unlink${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        if (std::shared_ptr<${prop.langTypeNS}>(this->${prop.instanceVariableName}) == ${prop.argumentName})
          {
            this->${prop.instanceVariableName} = std::shared_ptr<${prop.langTypeNS}>();
          }
      }
{% end source %}\
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstractProprietary or prop.isAttribute or not prop.isComplex() or not prop.isChoice) %}
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} property.
         *
         * @returns the ${prop.methodName} property.
         */
        ${prop.retType[qualifier]}
        get${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      ${prop.retType[qualifier]}
      ${klass.name}::get${prop.methodName} ()${qualifier}
      {
        return ${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set the ${prop.methodName} property.
         *
         * @param ${prop.argumentName} the value to set.
         */
        void
        set${prop.methodName} (${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      void
      ${klass.name}::set${prop.methodName} (${prop.argType} ${prop.argumentName})
      {
        this->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\
{% end %}\
{% when prop.maxOccurs > 1 and not klass.isAbstractProprietary %}
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOf${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOf${prop.methodName}List () const
      {
        return ${prop.instanceVariableName}.size();
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} list.
         *
         * @returns a reference to the list.
         *
         */
        const ${prop.instanceVariableType}&
        get${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ${prop.instanceVariableType}&
      ${klass.name}::get${prop.methodName}List () const
      {
        return ${prop.instanceVariableName};
      }
{% end source %}\

{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        ${prop.retType[qualifier]}
        get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.retType[qualifier]}
      ${klass.name}::get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier}
      {
        return ${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @throws std::out_of_range if the index is invalid.
         */
        void
        set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                               ${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                            ${prop.argType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        std::weak_ptr<${klass.type}> self(std::shared_ptr<${klass.type}>(this));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
        ${prop.instanceVariableName}.at(index) = ${prop.argumentName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Add ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to add.
         *
         * @todo Return list position?
         * @todo Detect and handle duplicates?
         */
        void
        add${prop.methodName} (${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::add${prop.methodName} (${prop.argType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        std::weak_ptr<${klass.type}> self(std::shared_ptr<${klass.type}>(this));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
        ${prop.instanceVariableName}.push_back(${prop.argumentName});
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Remove ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to remove.
         *
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        void
        remove${prop.methodName} (${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::remove${prop.methodName} (${prop.argType} ${prop.argumentName})
      {
        ${prop.instanceVariableType}::iterator i = std::find_if(${prop.instanceVariableName}.begin(),
                                                                ${prop.instanceVariableName}.end(),
                                                                compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != ${prop.instanceVariableName}.end())
          ${prop.instanceVariableName}.erase(i);
      }
{% end source %}\
{% end %}\
{% otherwise %}
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\

{% if klass.name == "LightSource" %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the LightSource type.
         *
         * @returns the concrete type of the LightSource.
         */
        virtual const std::string&
        getLightSourceType() const = 0;
{% end header %}\
{% end light source%}\
{% if klass.parents is not None and "LightSource" in klass.parents.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        const std::string&
        getLightSourceType() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getLightSourceType() const
      {
	static const std::string type("${klass.name}");
	return type;
      }
{% end source %}\
{% end has parent light source %}\
{% if klass.name == "Shape" %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the Shape type.
         *
         * @returns the concrete type of the Shape.
         */
        virtual const std::string&
        getShapeType() const = 0;
{% end header %}\
{% end shape%}\
{% if klass.parents is not None and "Shape" in klass.parents.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        const std::string&
        getShapeType() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getShapeType() const
      {
	static const std::string type("${klass.name}");
	return type;
      }
{% end source %}\
{% end has parent shape %}\

{% if not klass.isAbstractProprietary %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::asXMLElement
        virtual xerces::dom::Element&
        asXMLElement (xerces::dom::Document& document) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      xerces::dom::Element&
      ${klass.name}::asXMLElement (xerces::dom::Document& document) const
      {
        xerces::dom::Element nullelem;
        return asXMLElementInternal(document, nullelem);
      }
{% end source %}\

{% end %}\
{% if fu.SOURCE_TYPE == "header" %}\

 protected:
        // Documented in base class.
        virtual xerces::dom::Element&
        asXMLElementInternal (xerces::dom::Document& document,
                              xerces::dom::Element&  element) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      xerces::dom::Element&
      ${klass.name}::asXMLElementInternal (xerces::dom::Document& document,
                                           xerces::dom::Element&  element) const
      {
        // Creating XML block for ${klass.name}

{% if klass.isAbstractProprietary %}\
        // Class is abstract so we may need to create its "container" element
        if (std::string(element.getTagName()) != "${klass.name}")
          {
            xerces::dom::Element abstractElement =
              document.createElementNS(NAMESPACE, "${klass.name}");
            abstractElement.appendChild(element);
            element = abstractElement;
          }
{% end %}\
        if (!element)
          {
            xerces::dom::Element newElement = document.createElementNS(NAMESPACE, "${klass.name}");
            element = newElement;
          }

{% if klass.langBaseType is not None %}\
        // Element's text data
//            if (!this->value.empty()) {
{% if klass.langBaseType != 'std::string' %}\
        {
          std::ostringstream os;
          os << this->value;
          element.setTextContent(os.str());
        }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
        element.setTextContent(this->value);
{% end %}\
{% end %}\
{% for prop in klass.properties.values() %}\
{% if not klass.isAbstractProprietary or prop.isAttribute or not prop.isComplex() %}\
        {
{% choose %}\
{% when prop.name in customAsXMLElementPropertyContent %}\
{% if debug %}\
          // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customAsXMLElementPropertyContent[prop.name]}
{% if debug %}\
          // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end %}\
{% when prop.isReference and prop.maxOccurs > 1 %}\
          {
            // Reference property ${prop.name} which occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = ${prop.instanceVariableName}.begin();
                 i != ${prop.instanceVariableName}.end();
                 ++i)
              {
                // Note that this doesn't strictly need to be a
                // shared_ptr, but keep compatible with the rest of
                // the API to allow consistency for future
                // refactoring.
                std::shared_ptr<${prop.name}> o(std::make_shared< ${prop.name}>());
                std::shared_ptr<${prop.langTypeNS}> is(*i);
                if (is)
                  {
                    o->setID(is->getID());
                    element.appendChild(o->asXMLElement(document));
                  }
              }
          }
{% end %}\
{% when prop.isReference %}\
          {
            // Reference property ${prop.name}
            // Note that this doesn't strictly need to be a
            // shared_ptr, but keep compatible with the rest of the
            // API to allow consistency for future refactoring.
            std::shared_ptr<${prop.name}> o(std::make_shared< ${prop.name}>());
            std::shared_ptr<${prop.langTypeNS}> sv(${prop.instanceVariableName});
            o->setID(sv->getID());
            element.appendChild(o->asXMLElement(document));
          }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
          // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.maxOccurs == 1 and prop.isAttribute %}\
          // Attribute property ${prop.name}
          {
            std::ostringstream os;
            os << ${prop.instanceVariableName};
            element.setAttribute("${prop.name}", os.str());
          }
{% end %}\
{% when prop.maxOccurs == 1 and prop.isComplex() %}\
          // Element property ${prop.name} which is complex (has
          // sub-elements)
          if (${prop.instanceVariableName})
            element.appendChild(${prop.instanceVariableName}->asXMLElement(document));
{% end %}\
{% when prop.maxOccurs == 1 %}\
          // Element property ${prop.name} which is not complex (has no
          // sub-elements)
          {
            xerces::dom::Element ${prop.instanceVariableName}_element =
                                                               document.createElementNS(NAMESPACE, "${prop.name}");
            std::ostringstream os;
            os << ${prop.instanceVariableName};
            ${prop.instanceVariableName}_element.setTextContent(os.str());
            element.appendChild(${prop.instanceVariableName}_element);
          }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() %}\
          {
            // Element property ${prop.name} which is complex (has
            // sub-elements) and occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = ${prop.instanceVariableName}.begin();
                 i != ${prop.instanceVariableName}.end();
                 ++i)
              {
                element.appendChild((*i)->asXMLElement(document));
              }
          }
{% end %}\
{% when prop.maxOccurs > 1 %}\
          {
            // Element property ${prop.name} which is not complex (has no
            // sub-elements) which occurs more than once
            for (${prop.instanceVariableType}::const_iterator i = ${prop.instanceVariableName}.begin();
                 i != ${prop.instanceVariableName}.end();
                 ++i)
              {
                xerces::dom::Element ${prop.instanceVariableName}_element =
                                                                   document.createElementNS(NAMESPACE, "${prop.name}");
                std::ostringstream os;
                os << *i;
                ${prop.instanceVariableName}_element.setTextContent(os.str());
                element.appendChild(${prop.instanceVariableName}_element);
              }
          }
{% end %}\
{% otherwise %}\
{% if debug %}\
          // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
        }
{% end %}\
{% end %}\
        return ${klass.parentName}::asXMLElementInternal(document, element);
      }
{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
      };
{% end header %}\

    }
  }
}

{% if fu.SOURCE_TYPE == "header" %}\
#endif // ${fu.GUARD}

/*
 * Local Variables:
 * mode:C++
 * End:
 */
{% end header %}\

#!/usr/bin/env python
# encoding: utf-8
"""
Generate code to process OME-XML from an OME-XML schema.
"""

#
#  Copyright (C) 2007 University of Dundee. All rights reserved.
#
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

from __future__ import print_function

import logging
import sys
import os
import re
import codecs

# Needed to import modeltools
sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), 'python'))

from util import odict

from ome.modeltools.template import TemplateInfo
from ome.modeltools import config
from ome.modeltools import language
from ome.modeltools import generateds

try:
    from genshi.template import NewTextTemplate
except ImportError:
    print("""The genshi module was not found, but is required by xsd-fu.
If this is provided by your distribution, install the
"python-genshi" package or its equivalent.  Otherwise, run
"pip install genshi" (you may need to install pip first).""", file=sys.stderr)

    sys.exit(1)

from configobj import ConfigObj
from getopt import gnu_getopt, GetoptError
from glob import glob
from xml import sax

def guard(filename):
    filename = "_".join(filename.split(os.path.sep))
    filename = filename.upper()
    filename = re.sub("[^A-Z0-9]", "_", filename)
    return filename

def usage(error):
    """
    Prints usage so that we don't have to. :)
    """
    java = language.create("Java", config.DEFAULT_NAMESPACE, "/path/to/schemas")
    cpp = language.create("C++", config.DEFAULT_NAMESPACE, "/path/to/schemas")

    cmd = sys.argv[0]
    print("""Error: %s

xsd-fu: Generate classes from an OME-XML schema definition
Usage: %s command [options…] -o output_dir schema_files…

Options:
  -d, --dry-run                              Do not create output files
  -l, --language=lang                        Generated language
  --metadata-package=pkg                     Metadata package
  --ome-xml-metadata-package=pkg             OME-XML metadata class package
  --ome-xml-model-package=pkg                OME-XML model package
  --ome-xml-model-enums-package=pkg          OME-XML model enum package
  --ome-xml-model-enum-handlers-package=pkg  OME-XML model enum handler package
  -o, --output-directory=dir                 Generated output directory
  -q, --quiet                                Do not output file names
  -t, --template-path=path                   Genshi template path
  -v, --verbose                              Output generated file names
  -n, --xsd-namespace                        XML schema namespace

Available subcommands:
  debug
  doc_gen
  enum_handlers
  enum_types
  java_classes
  metadata
  omero_metadata
  omero_model
  omexml_metadata
  tab_gen

Default XSD namespace: "%s"

Default Java OME-XML package: "%s"
Default Java OME-XML enum package: "%s"
Default Java OME-XML enum handler package: "%s"
Default Java metadata package: "%s"
Default Java OME-XML metadata package: "%s"

Default C++ OME-XML package: "%s"
Default C++ OME-XML enum package: "%s"
Default C++ metadata package: "%s"
Default C++ OME-XML metadata package: "%s"

Examples:
  %s -l Java -n '%s' --ome-xml-model-package=%s -o omexml /path/to/schemas/ome.xsd
  %s -l C++ -n '%s' --ome-xml-model-package=%s -o omexml /path/to/schemas/ome.xsd

Report bugs to OME Devel <ome-devel@lists.openmicroscopy.org.uk>""" % \
    (error,
     cmd,
     java.modelNamespace,
     java.omexml_model_package, java.omexml_model_enums_package, java.omexml_model_enum_handlers_package, java.metadata_package, java.omexml_metadata_package,
     cpp.omexml_model_package, cpp.omexml_model_enums_package, cpp.metadata_package, cpp.omexml_metadata_package,
     cmd, java.modelNamespace, java.omexml_model_package,
     cmd, cpp.modelNamespace, cpp.omexml_model_package))
    sys.exit(2)

def main(opts):
    """
    Default main() that parses command line options and generates
    classes in the output directory.
    """

    model = generateds.parse(opts)
    fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_package)
    template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.CLASS_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
    base, filename = os.path.split(opts.lang.templatepath(config.CLASS_TEMPLATE))
    name, extension = os.path.splitext(filename)
    for obj in model.objects.values():
        fu.SOURCE_TYPE = opts.filetype;

        CUSTOM_CLASS_TEMPLATE = os.path.join(
            base, '%s_%s%s' % (name, obj.name, extension))
        customContent = ''
        if os.path.exists(CUSTOM_CLASS_TEMPLATE):
            customTemplate = NewTextTemplate(codecs.open(CUSTOM_CLASS_TEMPLATE, encoding='utf-8'), encoding='utf-8')
            customContent = customTemplate.generate(
                fu=fu, klass=obj, parents=parents, model=model)
            customContent = customContent.render(encoding='utf-8')
        customTemplates = glob(os.path.join(
                base, "%s_%s_update_*%s" % (name, obj.name, extension)))
        # BEGIN Custom templates for update()
        customUpdatePropertyContent = dict()
        for customTemplate in customTemplates:
            start = customTemplate.rfind("_") + 1
            end = customTemplate.rfind(".")
            propertyName = customTemplate[start:end]
            customTemplate = NewTextTemplate(codecs.open(customTemplate, encoding='utf-8'), encoding='utf-8')
            content = customTemplate.generate(
                fu=fu, klass=obj, parents=parents, model=model)
            content = content.render(encoding='utf-8')
            customUpdatePropertyContent[propertyName] = content
        # END Custom templates for update()
        # BEGIN Custom templates for asXMLElement()
        customTemplates = glob(os.path.join(
                base, "%s_%s_asXMLElement_*%s" % (name, obj.name, extension)))
        customAsXMLElementPropertyContent = dict()
        for customTemplate in customTemplates:
            start = customTemplate.rfind("_") + 1
            end = customTemplate.rfind(".")
            propertyName = customTemplate[start:end]
            customTemplate = NewTextTemplate(codecs.open(customTemplate, encoding='utf-8'), encoding='utf-8')
            content = customTemplate.generate(
                fu=fu, klass=obj, parents=parents, model=model)
            content = content.render(encoding='utf-8')
            customAsXMLElementPropertyContent[propertyName] = content
        # END Custom templates for asXMLElment()
        parents = model.resolve_parents(obj.name)

        try:
            fullname = opts.lang.generatedFilename(obj.name, opts.filetype)
            fullname = os.path.join("ome", "xml", "model", fullname)
        except ModelProcessingError:
            continue

        fu.GUARD = guard(fullname)

        fullname = os.path.join(opts.outdir, fullname)

        if (opts.verbose == True):
            print(fullname)
        if (opts.dryrun == True):
            continue

        outputDirectory = os.path.dirname(fullname)
        if not os.path.exists(outputDirectory):
            os.makedirs(outputDirectory)

        f = codecs.open(fullname, "w", encoding='utf-8')
        classContent = template.generate(
            fu=fu, klass=obj, model=model,
            customContent=customContent,
            customUpdatePropertyContent=customUpdatePropertyContent,
            customAsXMLElementPropertyContent=customAsXMLElementPropertyContent)
        classContent = classContent.render(encoding='utf-8')
        f.write(classContent.decode('utf-8'))
        f.close()

def enum_value_name(value):
    """
    Returns a valid Java enumeration name for an OME-XML enumeration value.
    """
    if re.match(r'^\d+', value):
        value = value.replace("0", "zero")
        value = value.replace("1", "one")
        value = value.replace("2", "two")
        value = value.replace("3", "three")
        value = value.replace("4", "four")
        value = value.replace("5", "five")
        value = value.replace("6", "six")
        value = value.replace("7", "seven")
        value = value.replace("8", "eight")
        value = value.replace("9", "nine")
    value = value.replace("-", "")
    return value.upper()

def enumTypesMain(opts):
    """
    Default main() that parses command line options and generates Java
    classes for enumeration types in an output directory.
    """

    model = generateds.parse(opts)
    fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_enums_package)
    template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.ENUM_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
    for obj in model.objects.values():
        for prop in obj.properties.values():
            if not prop.isEnumeration:
                continue

            try:
                fullname = opts.lang.generatedFilename(prop.langType, opts.filetype)
                fullname = os.path.join("ome", "xml", "model", "enums", fullname)
            except ModelProcessingError:
                continue

            fu.GUARD = guard(fullname)
            fu.SOURCE_TYPE = opts.filetype;

            fullname = os.path.join(opts.outdir, fullname)

            if (opts.verbose == True):
                print(fullname)
            if (opts.dryrun == True):
                continue

            outputDirectory = os.path.dirname(fullname)
            if not os.path.exists(outputDirectory):
                os.makedirs(outputDirectory)

            f = codecs.open(fullname, "w", encoding='utf-8')
            classContent = template.generate(fu=fu, klass=prop,
                                             enum_value_name=enum_value_name).render(encoding='utf-8')
            f.write(classContent.decode('utf-8'))
            f.close()

def enumTypesIncludeAll(opts):
    """
    Generate header to include all enum headers.
    """

    model = generateds.parse(opts)
    fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_enums_package)
    template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.ENUM_INCLUDEALL_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
    headers = model.getEnumHeaders()

    fullname = opts.lang.generatedFilename("enums", language.TYPE_HEADER)
    fullname = os.path.join("ome", "xml", "model", fullname)

    fu.GUARD = guard(fullname)
    fu.SOURCE_TYPE = language.TYPE_HEADER;
    fu.HEADERS = sorted(headers);

    fullname = os.path.join(opts.outdir, fullname)

    if (opts.verbose == True):
        print(fullname)
    if (opts.dryrun == True):
        return

    outputDirectory = os.path.dirname(fullname)
    if not os.path.exists(outputDirectory):
        os.makedirs(outputDirectory)

    f = codecs.open(fullname, "w", encoding='utf-8')
    classContent = template.generate(fu=fu).render(encoding='utf-8')
    f.write(classContent.decode('utf-8'))
    f.close()

def enumHandlersMain(opts):
    """
    Default main() that parses command line options and generates
    classes for enumeration handlers in an output directory.
    """

    model = generateds.parse(opts)
    fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_enum_handlers_package)
    base = os.path.join(os.path.split(os.path.abspath(__file__))[0], "cfg")
    configobj = ConfigObj(os.path.join(base, "enum_handler.cfg"))
    template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.ENUM_HANDLER_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
    for obj in model.objects.values():
        for prop in obj.properties.values():
            if not prop.isEnumeration:
                continue

            try:
                fullname = opts.lang.generatedFilename(prop.langType + "EnumHandler", opts.filetype)
                fullname = os.path.join("ome", "xml", "model", "enums", "handlers", fullname)
            except ModelProcessingError:
                continue

            fu.GUARD = guard(fullname)
            fu.SOURCE_TYPE = opts.filetype;

            fullname = os.path.join(opts.outdir, fullname)

            if (opts.verbose == True):
                print(fullname)
            if (opts.dryrun == True):
                continue

            outputDirectory = os.path.dirname(fullname)
            if not os.path.exists(outputDirectory):
                os.makedirs(outputDirectory)

            f = codecs.open(fullname, "w", encoding='utf-8')
            classContent = template.generate(fu=fu, klass=prop,
                             enum_value_name=enum_value_name, config=configobj).render(encoding='utf-8')
            f.write(classContent.decode('utf-8'))
            f.close()

def index_string(name, max_occurs, level):
    """Make a method signature string from an index name."""
    if name[:2].isupper():
        return "int %sIndex" % name
    else:
        return "int %s%sIndex" % (name[:1].lower(), name[1:])

def max_occurs_under_parent(model, parent, name):
    """
    Returns the maximum occurrances of a given object under its current
    parent.
    """
    parent = model.getObjectByName(parent)
    for prop in parent.properties.values():
        if prop.name == name:
            return prop.maxOccurs
    return 0

def resolve_hierarchy(results, model, names, func, child=None, key=None, level=0, min_occurs=2):
    """
    Resolves a representation of the hierarchical structure of element names.
    Updates the result list and returns a boolean True if the result list is
    multi-path, a boolean False otherwise.
    """
    is_multi_path = False
    if names is None:
        return is_multi_path
    for name in names.keys():
        # Set our key and instantiate our index list if we're the first level
        if level == 1:
            key = name
            results[key] = list()
        # We only want to add the index if the object count at this level
        # is greater than 1.
        max_occurs = max_occurs_under_parent(model, name, child)
        if len(names.keys()) > 1:
            is_multi_path = True
        is_child_multi_path = resolve_hierarchy(results, model, names[name], func, name, key, level + 1, min_occurs)
        if is_child_multi_path:
            is_multi_path = True
        if child is not None and max_occurs >= min_occurs:
            to_append = func(child, max_occurs, level)
            if to_append is not None:
                results[key].append(to_append)
    return is_multi_path

def processMetadataTemplate(template, outputFilename, opts):
    """
    Actually does the work of processing the model and providing the model
    to a given "Metadata" template for interface or concrete class code
    generation.
    """
    args = opts.args
    template = opts.lang.templatepath(template)

    model = generateds.parse(opts)
    indexes = dict()
    parents = dict()
    is_multi_path = dict()
    for obj in model.objects.values():
        name = obj.name
        indexes[name] = odict()
        parents[name] = model.resolve_parents(name)
        is_multi_path[name] = resolve_hierarchy(indexes[name], model,
                            {name: parents[name]},
                            index_string)

    fu = TemplateInfo(None, None)
    fu.max_occurs_under_parent = max_occurs_under_parent
    fu.resolve_hierarchy = resolve_hierarchy
    fu.METADATA_OBJECT_IGNORE = config.METADATA_OBJECT_IGNORE
    fu.METADATA_COUNT_IGNORE = config.METADATA_COUNT_IGNORE
    fu.BACK_REFERENCE_CLASS_NAME_OVERRIDE = config.BACK_REFERENCE_CLASS_NAME_OVERRIDE
    fu.ABSTRACT_PROPRIETARY_OVERRIDE = config.ABSTRACT_PROPRIETARY_OVERRIDE
    fu.DEFAULT_BASE_CLASS = model.opts.lang.getDefaultModelBaseClass()
    base, filename = os.path.split(template)
    name, extension = os.path.splitext(filename)
    template = NewTextTemplate(codecs.open(template, encoding='utf-8').read(), encoding='utf-8')
    from glob import glob
    customContent = dict()
    for customTemplate in glob(os.path.join(base, '%s_*' % (name))):
        filename = os.path.split(customTemplate)[1];
        filename = os.path.splitext(filename)[0]
        base, objectName, propertyName = filename.split("_")
        customTemplate = NewTextTemplate(codecs.open(customTemplate, encoding='utf-8').read(), encoding='utf-8')
        customTemplate = customTemplate.generate(
            fu=fu, model=model, parents=parents, is_multi_path=is_multi_path,
            indexes=indexes)
        if objectName not in customContent:
            customContent[objectName] = dict()
        customContent[objectName][propertyName] = customTemplate.render(encoding='utf-8')

    fullname = opts.lang.generatedFilename(outputFilename, opts.filetype)

    fu.GUARD = guard(fullname)
    fu.SOURCE_TYPE = opts.filetype;

    fullname = os.path.join(opts.outdir, fullname)

    if (opts.verbose == True):
        print(fullname)
    if (opts.dryrun == True):
        return

    outputDirectory = os.path.dirname(fullname)
    if not os.path.exists(outputDirectory):
        os.makedirs(outputDirectory)

    content = template.generate(fu=fu, model=model, parents=parents,
                    is_multi_path=is_multi_path, indexes=indexes,
                    customContent=customContent).render(encoding='utf-8')
    f = codecs.open(fullname, "w", encoding='utf-8')
    f.write(content.decode('utf-8'))
    f.close()

def omeXmlMetadataMain(opts):
    """
    OME-XML main() that parses command line options and generates a
    MetadataStore and MetadataRetrieve implementation.
    """

    relpath = os.path.join(*opts.lang.omexml_metadata_package.split(opts.lang.package_separator))

    processMetadataTemplate(config.OMEXML_METADATA_TEMPLATE,
                os.path.join(relpath, "OMEXMLMetadataImpl"),
                opts)

def omeroMetadataMain(opts):
    """
    Default main() that parses command line options and generates a
    MetadataRetrieve implementation.
    """

    processMetadataTemplate(config.OMERO_METADATA_TEMPLATE, "OmeroMetadata",
                opts)

def omeroModelMain(opts):
    """
    Default main() that parses command line options and generates a
    MetadataRetrieve implementation.
    """

    processMetadataTemplate(config.OMERO_MODEL_TEMPLATE, "OmeroModel.xml",
                opts)

def metadataMain(opts):
    """
    Default main() that parses command line options and generates a
    MetadataStore implementation.
    """

    relpath = os.path.join(*opts.lang.metadata_package.split(opts.lang.package_separator))

    processMetadataTemplate(config.METADATA_STORE_TEMPLATE,
                os.path.join(relpath, "MetadataStore"),
                opts)

    processMetadataTemplate(config.METADATA_RETRIEVE_TEMPLATE,
                os.path.join(relpath, "MetadataRetrieve"),
                opts)

    processMetadataTemplate(config.METADATA_AGGREGATE_TEMPLATE,
                os.path.join(relpath, "AggregateMetadata"),
                opts)

    processMetadataTemplate(config.FILTER_METADATA_TEMPLATE,
                os.path.join(relpath, "FilterMetadata"),
                opts)

    processMetadataTemplate(config.DUMMY_METADATA_TEMPLATE,
                os.path.join(relpath, "DummyMetadata"),
                opts)

def debugMain(opts):
    """
    Debugging main() that does not parse the command line and spits
    generated data to STDOUT.
    """

    model = generateds.parse(opts)
    fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_package)
    template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.CLASS_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
    base, filename = os.path.split(opts.lang.templatepath(config.CLASS_TEMPLATE))
    name, extension = os.path.splitext(filename)
    for obj in model.objects.values():
        parents = model.resolve_parents(obj.name)
        if obj.name in ["StructuredAnnotations"]:
            CUSTOM_CLASS_TEMPLATE = os.path.join(base, '%s_%s%s' % (name, obj.name, extension))
            customContent = ''
            if os.path.exists(CUSTOM_CLASS_TEMPLATE):
                customTemplate = NewTextTemplate(codecs.open(CUSTOM_CLASS_TEMPLATE, encoding='utf-8'), encoding='utf-8')
                customContent = customTemplate.generate(
                    fu=fu, klass=obj, parents=parents, model=model)
                customContent = customContent.render(encoding='utf-8')
            print("Dump: %s" % obj.__dict__)
            print("Element Dump: %s" % obj.element.__dict__)
            print(" +-- %s(base=%s, type=%s)" % (obj.name, obj.base, obj.type))
            for prop in obj.properties.values():
                print("Dump: %s" % prop.__dict__)
                print("Delegate Dump: %s" % prop.delegate.__dict__)
                print(" +---- %s(%s) [%d:%d]" % \
                    (prop.name, prop.type, prop.minOccurs, prop.maxOccurs))
            print("\n")

            fu.GUARD = guard(fullname)
            fu.SOURCE_TYPE = opts.filetype;

            print(template.generate(
                    fu=fu, klass=obj, parents=parents, model=model, customContent=customContent).render(encoding='utf-8'))

def docGenMain(opts):
    """
    Documentation main() that does not parse the command line and spits
    generated wiki formatted docs to STDOUT.
    Added by Andrew Patterson (July 2008) to generate content for
    the ArityOfSchema page on http://ome-xml.org
    """

    for theSchemas in [
    ["OME",           "../specification/InProgress/ome.xsd"],
    ["SPW",           "../specification/InProgress/SPW.xsd"],
    ["BinaryFile",    "../specification/InProgress/BinaryFile.xsd"],
    ["SA",            "../specification/InProgress/SA.xsd"],
    ["ROI",           "../specification/InProgress/ROI.xsd"]
    ]:
        prefix = theSchemas[0] + ":"
        opts.args = [theSchemas[1]]
        model = generateds.parse(opts)
        fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_package)
        template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.CLASS_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
        print(" == `%s` ==" % (prefix))
        for obj in model.objects.values():
            print(" === %s%s ===" % (prefix, obj.name))
            print(" * %s%s(base = `%s`, type = `%s`)" % (prefix, obj.name, obj.base, obj.type))
            for prop in obj.properties.values():
                print("   * %s%s:%s( `%s` ) ![%d:%d]" % \
                    (prefix, obj.name, prop.name, prop.type, prop.minOccurs, prop.maxOccurs))
            print("\n")

def tabGenMain(opts):
    """
    Documentation main() that does not parse the command line and puts
    tab sperated format to STDOUT.
    Added by Andrew Patterson (October 2008) to generate content for arity spreadsheet
    """

    for theSchemas in [
            ["OME",       "../specification/InProgress/ome.xsd",
                [["OME", "OME:"]]],
            ["ROI",       "../specification/InProgress/ROI.xsd",
                [["ROI", "OME:ROI:"]]],
            ["SPW",       "../specification/InProgress/SPW.xsd",
                [["Plate", "OME:Plate:"],
                ["Screen", "OME:Screen:"]]],
            ["SA",        "../specification/InProgress/SA.xsd",
                [["StructuredAnnotations", "OME:StructuredAnnotations:"]]],
            ["BinaryFile","../specification/InProgress/BinaryFile.xsd",
                [["BinaryFile", "OME:Instrument:OTF:BinaryFile:"]]]
        ]:
        prefix = theSchemas[0] + ":"
        opts.args = [theSchemas[1]]
        model = generateds.parse(opts)
        fu = TemplateInfo(opts.outdir, opts.lang.omexml_model_package)
        template = NewTextTemplate(codecs.open(opts.lang.templatepath(config.CLASS_TEMPLATE), encoding='utf-8').read(), encoding='utf-8')
        for theToplevelNode in theSchemas[2]:
            parentlist(model, theToplevelNode[0], theToplevelNode[1])

def parentlist(model, name, pre):
    for obj in model.objects.values():
        if obj.name in [name]:
            #print pre + name;
            for prop in obj.properties.values():
                if prop.name[-14:] == "_BackReference":
                    print("-\t-\t" + prop.name + "\t" + prop.type + "\tback\t" + pre + prop.name)
                    pass
                else:
                    if prop.name == name:
                        print("%s\t%s" % (prop.minOccurs, prop.maxOccurs ) + "\t" + prop.name + "\t" + prop.type + "\trecursion\t" + pre + prop.name + " - recursion")
                    else:
                        print("%s\t%s" % (prop.minOccurs, prop.maxOccurs ) + "\t" + prop.name + "\t" + prop.type + "\t\t" + pre + prop.name)
                        parentlist(model, prop.type, pre + prop.name + ":")


class options:
    def __init__(self, args):
        try:
            self.options, self.args = gnu_getopt(args[1:], "df:l:o:p:n:t:qv",
                                                 ['dry-run',
                                                  'file-type=',
                                                  'language=',
                                                  'output-directory=',
                                                  'ome-xml-model-package=',
                                                  'ome-xml-model-enums-package=',
                                                  'ome-xml-model-enum-handlers-package=',
                                                  'metadata-package=',
                                                  'ome-xml-metadata-package=',
                                                  'xsd-namespace=',
                                                  'template-path=',
                                                  'quiet',
                                                  'verbose'])
        except GetoptError as err:
            usage(err)

        omexml_model_package = None
        omexml_model_enums_package = None
        omexml_model_enum_handlers_package = None
        metadata_package = None
        omexml_metadata_package = None

        self.outdir = None
        self.package = None # Used for output classes only
        self.namespace = config.DEFAULT_NAMESPACE
        self.lang = "Java"
        self.filetype = language.TYPE_SOURCE
        self.templatepath = os.path.dirname(os.path.realpath(__file__))
        self.verbose = True
        self.dryrun = False
        for option, argument in self.options:
            if option == "-f":
                if argument == language.TYPE_SOURCE:
                    self.filetype = language.TYPE_SOURCE
                elif argument == language.TYPE_HEADER:
                    self.filetype = language.TYPE_HEADER
                else:
                    usage("Invalid filetype; source and header are the only valid options")
                    sys.exit(1)
            if option in ('-l', '--language'):
                self.lang = argument
            if option in ('-o', '--output-directory'):
                self.outdir = argument
            if option in ('--ome-xml-model-package'):
                omexml_model_package = argument
            if option in ('--ome-xml-model-enums-package'):
                omexml_model_enums_package = argument
            if option in ('--ome-xml-model-enum-handlers-package'):
                omexml_model_enum_handlers_package = argument
            if option in ('--metadata-package'):
                metadata_package = argument
            if option in ('--ome-xml-metadata-package'):
                omexml_metadata_package = argument
            if option in ('-n', '--xsd-namespace'):
                self.namespace = argument
            if option in ('-t', '--template-path'):
                self.templatepath = argument
            if option in ('-q', '--quiet'):
                self.verbose = False
            if option in ('-v', '--verbose'):
                self.verbose = True
            if option in ('-d', '--dry-run'):
                self.dryrun = True
        # Create language object
        self.lang = language.create(self.lang, self.namespace, self.templatepath)
        if omexml_model_package is not None:
            self.lang.omexml_model_package = omexml_model_package
        if omexml_model_enums_package is not None:
            self.lang.omexml_model_enums_package = omexml_model_enums_package
        if omexml_model_enum_handlers_package is not None:
            self.lang.omexml_model_enum_handlers_package = omexml_model_enum_handlers_package
        if metadata_package is not None:
            self.lang.metadata_package = metadata_package
        if omexml_metadata_package is not None:
            self.lang.omexml_metadata_package = omexml_metadata_package

        if len(self.args) < 1:
            usage('Missing subcommand')

        if self.outdir is None:
            usage("Output directory must be specified")
            sys.exit(1)
        if not os.path.exists(self.outdir):
            os.makedirs(self.outdir)

        self.command = self.args[0]
        self.args = self.args[1:]

        if (self.command != "doc_gen" and self.command != "tab_gen") and len(self.args) < 1:
            usage("No schema files specified")

if __name__ == '__main__':
    opts = options(sys.argv)

    opts.package = opts.lang.omexml_model_package
    if opts.command == "enum_types":
        opts.package = opts.lang.omexml_model_enums_package
    elif opts.command == "enum_handlers":
        opts.package = opts.lang.omexml_model_enum_handlers_package
    elif opts.command == "metadata":
        opts.package = opts.lang.metadata_package
    elif opts.command == "omexml_metadata":
        opts.package = opts.lang.omexml_metadata_package

    if opts.command == "java_classes":
        main(opts)
    elif opts.command == "omexml_metadata":
        omeXmlMetadataMain(opts)
    elif opts.command == "omero_metadata":
        omeroMetadataMain(opts)
    elif opts.command == "omero_model":
        omeroModelMain(opts)
    elif opts.command == "metadata":
        metadataMain(opts)
    elif opts.command == "enum_types":
        enumTypesMain(opts)
    elif opts.command == "enum_includeall":
        enumTypesIncludeAll(opts)
    elif opts.command == "enum_handlers":
        enumHandlersMain(opts)
    elif opts.command == "doc_gen":
        docGenMain(opts)
    elif opts.command == "tab_gen":
        tabGenMain(opts)
    elif opts.command == "debug":
        debugMain(opts)
    else:
        usage('Unrecognized subcommand: %s' % opts.command)

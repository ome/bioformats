<?xml version = "1.0" encoding = "UTF-8"?>
<!--Generated by Turbo XML 2.3.1.100. Conforms to w3c http://www.w3.org/2001/XMLSchema-->
<xsd:schema xmlns:xsd = "http://www.w3.org/2001/XMLSchema"
	 elementFormDefault = "qualified">
<!--
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #
    # Copyright (C) 2003-2011 Open Microscopy Environment
    #       Massachusetts Institute of Technology,
    #       National Institutes of Health,
    #       University of Dundee,
    #       University of Wisconsin at Madison
    #
    # This work is licensed under the
    #       Creative Commons Attribution 3.0 Unported License.
    # To view a copy of this license, visit
    #       http://creativecommons.org/licenses/by/3.0/
    # or send a letter to
    #       Creative Commons, 444 Castro Street, Suite 900,
    #       Mountain View, California, 94041, USA.
    # For attribution instructions, visit
    #       http://www.openmicroscopy.org/info/attribution
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->
	<xsd:element name = "Declaration">
		<xsd:annotation>
			<xsd:documentation>States module requirements.
Formal Inputs are optional because input requirements may be specified by guaranteed image attributes. For example, OME_Image_XYZ_stats requires a path to the OME repository file, and Dimensions.
These are given by &lt;RawImageFilePath>, &lt;sizeX>, &lt;sizeY>, &lt;sizeZ>, &lt;sizeT>, and &lt;sizeW>.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "FormalInput" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "FormalOutput" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalInput">
		<xsd:annotation>
			<xsd:documentation>Specifies an input requirement for a module. Image dimensions and image file locations (repository or other format) should not be specified with this. Image dimensions are intrisic to an image. They do not represent a special requirement. Image file locations and contents are specified by other elements. Specifically, RawImageFile, RawImageFilePath, XYPlaneFile, and XYPlaneFilePath.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "LookupTable" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "UserDefined" default = "false" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>OME interprets this as a recommendation rather than a requirement.

Tied to DB. Table FORMAL_INPUTS Column USER_DEFINED

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "SemanticTypeName" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>References a SemanticType

Represented in DB as FORMAL_INPUT.ATTRIBUTE_ID
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalOutput">
		<xsd:annotation>
			<xsd:documentation>Specifies an output element of a module.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "IBelongTo">
				<xsd:annotation>
					<xsd:documentation>Concerning MakeNewFeature attribute of ExecutionInstructions, if a new feature type is made, then there are two possible places a formal output attribute can be stored: It can be stored as an attribute of the FeatureIterator, or it can be stored as an attribute of the new Feature.
This tag is supposed to specify which. Can be left blank if module does not make new iterator.

Tied to DB. FORMAL_OUTPUTS.FEATURE_TAG
Processed before storage to DB

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "[Feature]"/>
						<xsd:enumeration value = "[Iterator]"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "SemanticTypeName" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>References a SemanticType

Represented in DB as FORMAL_OUTPUT.ATTRIBUTE_ID
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Table">
		<xsd:annotation>
			<xsd:documentation>Declares a table in the DB.
Maps to table DATATYPES during module import.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Column" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Granularity" use = "required">
				<xsd:annotation>
					<xsd:documentation>This specifies if this table is an attribute of Dataset, Image, or Feature.

Tied to DB. DATA_TABLES.ATTRIBUTE_TYPE

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "D"/>
						<xsd:enumeration value = "I"/>
						<xsd:enumeration value = "F"/>
						<xsd:length value = "1"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "TableName" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. DATA_TABLES.TABLE_NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. DATA_TABLES.DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTable">
		<xsd:annotation>
			<xsd:documentation>Describes valid values for an input. Think enumerations, (a list of valid values).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "LookupTableEntry" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. LOOKUP_TABLES.NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. LOOKUP_TABLES.DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTableEntry">
		<xsd:complexType>
			<xsd:attribute name = "Value" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. LOOKUP_TABLE_ENTRIES.VALUE</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Label">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. LOOKUP_TABLE_ENTRIES.LABEL</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModuleLibrary">
		<xsd:annotation>
			<xsd:documentation>An analysis module is defined by two things:
1) A program
2) An interface
A single program may have multiple interfaces. Why do you need multiple interfaces?
Pretend you have a program that calculates simple statistics on the pixels of an image. You can specify which statistics you want via parameters.

Typing
./stats -mean -sigma image1

will ouput
Image | mean | sigma
image1 12.4 1

Typing
./stats -geomean -mean image1

will output
Image | geomean | mean
image1 12.2 12.4

The outputs are completely different. You need to specify an interface for each of these behaviors.
Or pretend you have a powerful program that can do 10 unrelated tasks, each of which outputs an image. While the outputs are the same type and format, they represent 10 completely different things. In this case, it might make sense to define 10 corrosponding AnalysisModule to represent the 10 logical functions.

In any case, use AnalysisModule to define an interface and Program to store installation software for a program.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "AnalysisModule" maxOccurs = "unbounded"/>
				<xsd:element ref = "Program" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "SemanticTypeDefinitions"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModule">
		<xsd:annotation>
			<xsd:documentation>Describes an interface to use with a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Declaration"/>
				<xsd:element ref = "ExecutionInstructions" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "ModuleName" use = "required">
				<xsd:annotation>
					<xsd:documentation>PROGRAM_NAME in the database is a misnomer. It really should be changed to NAME.

Tied to DB. Table PROGRAMS Column PROGRAM_NAME

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Category">
				<xsd:annotation>
					<xsd:documentation>Specifies what category this program belongs to.

Tied to DB. Table PROGRAMS Column CATEGORY

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "32"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table PROGRAMS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "isStreamAlgorithm" default = "false" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. The database location doesn't even exist yet.

If the output of the analysis will be the same when pixel positions are scrambled, the analysis is a stream algorithm.
Examples of stream algorithms are:
	A statistics module that produces mean, geometric mean, standard deviation, etc. for pixel intensities.
	A module to cross correlate pixel intensities across wavelengths.
Example of an algorithms that is not a stream algorithm is:
	FindSpots. (It's a module to find blobs in an image.)

If a module is a stream algorithm, it can function across the x, y, z, and time dimensions.

Tied to DB. Table PROGRAMS Column IS_STREAM_ALGORITHM

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "ModuleType" use = "required">
				<xsd:annotation>
					<xsd:documentation>As more handlers, are added, this part of the schema needs to be changed

Tied to DB. Table PROGRAMS Column MODULE_TYPE

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "OME::Analysis::PerlHandler"/>
						<xsd:enumeration value = "OME::Analysis::CLIHandler"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a Program Element. It should corrospond to a ProgramID specified in a Program Element.
Referential integrity is not enforced by this schema. That is, verification against the schema will not detect an error here if you make a typo.

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "FeatureIterator">
				<xsd:annotation>
					<xsd:documentation>If the module iterates over a feature, specify the iterator here. It will reference a feature via the TAG column of the FEATURES table.
An example of a module that does not iterate over a feature is Find Cells. It examines one image at a time, hence it iterates over an image, not a feature. It produces zero or more features (Ã‡ell) per image. These Cell features belong to an image.
This module would not get a FeatureIterator attribute.
An example of a module that iterates over a feature is Find Golgi. It examines one CELL at a time. A cell is a feature, hence the module iterates over features, not images or datasets. It produces zero or more Golgi features per Cell feature. These Golgi features belong to a Cell feature.
This module would get a FeatureIterator attribute of "CELL".

Tied to DB. Table PROGRAMS Column DEFAULT_ITERATOR

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "128"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "NewFeatureName">
				<xsd:annotation>
					<xsd:documentation>If this module makes new features, then the new Feature's name needs to be specified here.
If the module does not make new features, do not specify a value for this attribute.

Tied to DB. PROGRAMS.NEW_FEATURE_TAG

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "128"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Program">
		<xsd:annotation>
			<xsd:documentation>Stores an installation package and installation script for a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InstallationScript"/>
				<xsd:element ref = "InstallationFile"/>
			</xsd:sequence>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by AnalysisModule elements. Accordingly, each FormalOutput needs to be unique. Schema verification does not check for this. Verification against the schema will not detect an error here if you make a typo.


					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Name">
				<xsd:annotation>
					<xsd:documentation>Program name.

Unclear how this would be used. DB location PROGRAMS.PROGRAM_NAME is populated by XML attribute AnalysisModule.Name.

					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Version" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Currently unused</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinaryFile">
		<xsd:annotation>
			<xsd:documentation>Describes a binary file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "External"/>
				<xsd:element ref = "BinData"/>
			</xsd:sequence>
			<xsd:attribute name = "FileName">
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "External">
		<xsd:annotation>
			<xsd:documentation>Describes a file location.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "href" use = "required" type = "xsd:anyURI">
				<xsd:annotation>
					<xsd:documentation>file location</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Offset" type = "xsd:integer"/>
			<xsd:attribute name = "SHA1" use = "required" type = "Hex40"/>
			<xsd:attribute name = "Compression">
				<xsd:annotation>
					<xsd:documentation>Only necessary if file is compressed.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "gzip"/>
						<xsd:enumeration value = "bzip2"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinData" type = "xsd:base64Binary"/>
	<xsd:simpleType name = "Hex40">
		<xsd:restriction base = "xsd:hexBinary">
			<xsd:length value = "20"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:element name = "InstallationScript">
		<xsd:annotation>
			<xsd:documentation>The script should interface with the OME API to find all information it needs. (i.e. installation path) It also needs to set the location of the program after the program is installed. The location should be set through the API, but it will propogate to the LOCATION column of the PROGRAMS table.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InstallationFile">
		<xsd:annotation>
			<xsd:documentation>Contains a packaged or zipped installation files (binaries or source code).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
			<xsd:attribute name = "Format" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. Don't bother with it unless you know more about it.

Specifies the packaging and/or compression format of the Installation file.

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Column">
		<xsd:complexType>
			<xsd:attribute name = "ColumnName" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Specifies a column Name in the database.

Tied to database. DATA_COLUMNS.COLUMN_NAME

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "SQL_DataType" use = "required">
				<xsd:annotation>
					<xsd:documentation>When it is necessary to generate a table and/or column in the Database, the importer needs to tell the database a datatype.
Not all SQL datatypes are supported currently.


					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "integer"/>
						<xsd:enumeration value = "double"/>
						<xsd:enumeration value = "float"/>
						<xsd:enumeration value = "boolean"/>
						<xsd:enumeration value = "string"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. DATA_COLUMNS.DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "ExecutionInstructions"/>
	<xsd:element name = "SemanticTypeDefinitions">
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "DataTypes"/>
				<xsd:element ref = "SemanticType" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "DataTypes">
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Table" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "SemanticType">
		<xsd:annotation>
			<xsd:documentation>Defines a semantic type.

Restrictions:
Every SemanticElement must be in the same table.

Notes:
Granularity is infered from granularity of table.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "SemanticElement" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. ATTRIBUTE_TYPE.NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. ATTRIBUTE_TYPE.DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "SemanticElement">
		<xsd:complexType>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. ATTRIBUTE_COLUMNS.NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. ATTRIBUTE_COLUMNS.DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "TableName" use = "required">
				<xsd:annotation>
					<xsd:documentation>References a Table</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ColumnName" use = "required">
				<xsd:annotation>
					<xsd:documentation>References a Column.

This, along with TableName, uniquely identifies a db location for this element.
Represented in DB as ATTRIBUTE_COLUMNS.DATA_COLUMN_ID
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
</xsd:schema>